<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" href="data:;base64,=">
        <title> Basic Snake </title>
        <style>
            :root {
                --main-bg-color: #171717;
                --canvas-bg-color: #2f2f2f;
                --app-green: limegreen;
            }
            html {
                height: 100%;
                background-color: var(--main-bg-color);
                color: #eee;
                font-family: system-ui;
                font-size: 18px;
            }
            body {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            h1, h2, h3 {
                margin: 5px 0;
            }
            .info-display {
                background-color: var(--canvas-bg-color);
                margin: 20px 0;
                padding: 8px;
                display: flex;
                align-items: center;
                width: 480px;
                justify-content: space-around;
            }
            .game-info {
                flex-direction: column;
                align-items: unset;
                font-size: 14px;
            }
            #mainCanvasWrapper {
                width: auto;
                height: auto;
                background-color: var(--canvas-bg-color);
            }
            #playButton {
                background-color: inherit;
                border: 1px solid var(--app-green);
                color: var(--app-green);
                cursor: pointer;
                outline: none !important;
                font-size: 16px;
            }
            .score-display {
                color: var(--app-green);
                display: inline-block;
                min-width: 30px;
            }
            .arrows {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            .arrow {
                font-size: 24px;
                cursor: pointer;
                padding: 2px;
                margin: 5px 8px;
                display: inline-block;
            }
            .game-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
            }
        </style>
    </head>
    <body>
        <div class="info-display game-info">
            <div class="game-header">
                <h1><u>Snake</u></h1>
                <h3>Game Information</h3> 
            </div>
            <div>- Start the game via the Play button or by hiting Enter on your keyboard.</div>
            <div>- Change direction via your keyboard's arrow keys or the arrows on the bottom right.</div>
            <div>- The snake can't reverse direction without turning. He's not coordinated!</div>
        </div>
        <div id="mainCanvasWrapper">
            <canvas id="mainCanvas" width="500" height="500"></canvas>
        </div>
        <div class="info-display">
            <button id="playButton" onclick="setupAndPlay()">Play</button>
            <h4>Curent Score: <span class="score-display" id="currentScore">0</span></h4>
            <h4>High Score: <span class="score-display" id="highScore">0</span></h4>
            <div class="arrows">
                <div class="top"><span></span><span onclick="onUp()" class="arrow">&#8593;</span><span></span></div>
                <div class="middle"><span onclick="onLeft()" class="arrow">&#8592;</span><span></span><span onclick="onRight()" class="arrow">&#8594;</span></div>
                <div class="bottom"><span></span><span onclick="onDown()" class="arrow">&#8595;</span><span></span></div>
            </div>
        </div>

        <script>
            /* HTML Canvas and contexts - defined with types for easier use in IDE's */
            /** @type {HTMLCanvasElement} the canvas used to run and interact with the game */
            const mainCanvas = document.getElementById("mainCanvas");

            /** @type {CanvasRenderingContext2D} the 2d context used for snake */
            const mainCanvasContext = mainCanvas.getContext("2d");

            // These properties don't change during runtime and can be set as "const"
            const gameSpeed = 15; // indicates how fast the snake moves across the canvas, raise to increase speed
            const gameOverColor = "red"; // color to draw the snake as if the game is over
            const snakeSideLength = 15;
            const pointsPerFood = 10; // how many points you earn for each food item consumed
            const canvasColor = "#2f2f2f";
            const foodColor = "#c614d0";
            const directions = {up: "up", right: "right", down: "down", left: "left"}; // all available directions the snake can go

            // These properties change during runtime, and have their values reinitialized in the reset() function
            let snakeColor = "#0ba99f";
            let currentFood; // the current food piece on the canvas
            let direction = directions.down; // the current direction of the snake
            let skipNextPopCycle = false; // if true, food has just been consumed, and the next "pop" in movement (removing the tail) should be skipped
            let snake = [{x: 240, y: 240, direction: directions.down}]; // tracks the x and y position of each snake piece, as well as the direction it's travelling
            let gameOver = false; // if true, the user has lost - either by colliding with the edge or its own tail
            let directionQueue = []; // queue for direction changes to only allow one direction shift per game cycle
            let currentScore = 0;

            // These properties change, but aren't reinitialized in reset() due to them persisting between games
            let highScore = 0;

            // Add a keydown listener for arrow keys, allowing for the snake to change direction when the user uses the arrow keys
            document.onkeydown = function(e) {
                switch (e.keyCode) {
                    // Enter key - restarts the game
                    case 13:
                        setupAndPlay();
                        break;

                    // Arrow key cases - controls the snake in the game
                    case 37: // left arrow
                        onLeft();
                        break;
                    case 38: // up arrow
                        onUp();
                        break;
                    case 39: // right arrow
                        onRight();
                        break;
                    case 40: // down arrow
                        onDown();
                        break;
                }
            };

            /** Functions for adding to the direction queue when a direction is triggered (Arrow keys or the arrows on the page) */
            function onLeft() {
                addToDirectionQueue(directions.left);
            }
            function onUp() {
                addToDirectionQueue(directions.up);
            }
            function onRight() {
                addToDirectionQueue(directions.right);
            }
            function onDown() {
                addToDirectionQueue(directions.down);
            }

            /** Sets properties that can change over the course of the game to their initial values */
            function reset() {
                snakeColor = "#0ba99f";
                currentFood = undefined; // the current food piece on the canvas
                snake = [{x: 240, y: 240, direction: directions.down}]; // tracks the x and y position of each snake piece, as well as the direction it's travelling
                gameOver = false; // if true, the user has lost - either by colliding with the edge or its own tail
                directionQueue = []; // queue for direction changes to only allow one direction shift per game cycle
                currentScore = 0;
                updateCurrentScore(currentScore);
            }

            /** Resets game values and calls play(). Triggered by the user clicking the Play button. */
            function setupAndPlay() {
                reset();
                // Give a small timeout before the game starts to allow for users to adjust between the play click and the game starting
                setTimeout(() => {
                    play();
                }, 60);
            }

            /**
                TODO's
                    (1) Make speed configurable - original 50 is too high for normal players
                    (2) Make styles of canvas, wrapping and info elements, and in-game elements responsive to mobile
            */

            // Main game function. Calls itself recursively to run the game.
            function play() {
                moveSnake(snake);
                clear(); // clear the previous game state
                // if the game isn't over, perform game actions like moving the snake and checking for food
                if (!gameOver) {
                    checkDirection();
                    checkFood();
                }
                drawSnake(snake);
                if (gameOver) {
                    if (currentScore > highScore) {
                        updateHighScore(currentScore);
                    }                    
                }
                setTimeout(() => !gameOver ? play() : '', 60); // basically a tick(), redrawing the game canvas every X seconds. will not redraw if the game is over
            }

            /** Given a score, update the highScore and update the DOM element displaying it */
            function updateHighScore(score) {
                highScore = score;
                document.getElementById("highScore").innerText = highScore;
            }

            /** Given a score, update the currentScore and update the DOM element displaying it */
            function updateCurrentScore(score) {
                currentScore = score;
                document.getElementById("currentScore").innerText = currentScore;
            }

            /** Returns true if the game is over, because the user hit a side or a snake tail piece.
            *   @param {Object} snakeHead - a piece of a snake, usually the head, to check if it causes a game over. 
            */
            function isGameOver(snakeHead) {
                // Check for any movement-based game over states. If any are found, log the state of the loss.
                if (isPieceOffBoard(snakeHead)) {
                    console.log(`Lost from hitting the board's edge. Snake's head position: ${Object.values(snakeHead)}`);
                    snakeColor = gameOverColor;
                    return true;
                } else if (doesPieceOverlapWithSnake(snakeHead, false)) {
                    console.log(`Lost from the snake's head hitting a tail piece. Snake's head position: ${Object.values(snakeHead)}`);
                    snakeColor = gameOverColor;
                    return true;
                } else {
                    return false;
                }
            }

            /** @returns {boolean} true if a given piece is off the board in either x or y axis */
            function isPieceOffBoard(piece) {
                let offBoard = piece.x < 0 || (piece.x + snakeSideLength) > mainCanvas.width; // check for off board in the x direction
                offBoard = offBoard || (piece.y < 0 || (piece.y + snakeSideLength) > mainCanvas.height); // check for off board in the y direction
                return offBoard;
            }

            /** Performs snake-food related actions, like building, drawing, or consuming it */
            function checkFood() {
                // First, check if the snake's head overlaps food - if so, consume it
                currentFood && doPiecesOverlap(snake[0], currentFood) ? consumeFood() : "";

                // If food doesn't exist, either from initial state or consumption, build it again
                if (!currentFood) {
                    currentFood = buildFood();
                }

                // Draw the current food object
                drawFood();
            }

            /** Destroys the food currently on the board and attempts to add a piece to the snake's tail */
            function consumeFood() {
                if (currentFood) {
                    // Clear the current food and determine the last snake piece's position
                    currentFood = undefined;

                    // Update the current score
                    updateCurrentScore(currentScore + pointsPerFood);

                    // Indicate that the next "pop" cycle of movement (removing the tail and adding a head) should be skipped, adding a head without removing a tail
                    skipNextPopCycle = true;
                }
            }

            /** Draws the currentFood object on the canvas */
            function drawFood() {
                mainCanvasContext.fillStyle = foodColor;
                drawPiece(currentFood);
            }

            /** Returns a new food object that doesn't overlap the snake. */
            function buildFood() {
                // Generate a random piece that does not overlap the snake
                let food;
                let doesOverlap = true;
                while(doesOverlap) {
                    food = getRandomPiece();
                    doesOverlap = doesPieceOverlapWithSnake(food, true);
                }

                // Once reached, we've generated a food piece that doesn't overlap the snake. Return it.
                return food;
            }

            /** Given a piece, check if it overlaps the snake. Will only check the head piece if checkHead === true. */
            function doesPieceOverlapWithSnake(piece, checkHead) {
                // Cache where the piece ends on both axis so it doesn't have to be calculated on each iteration
                let pieceXEnd = piece.x + snakeSideLength;
                let pieceYEnd = piece.y + snakeSideLength;
                // Check if the piece overlaps with any snake piece
                let doesOverlap = false;
                snake.find((snakePiece, index) => {
                    // Only run for index === 0 if checkHead === true
                    if (checkHead || index !== 0) {
                        doesOverlap = doesOverlap || doPiecesOverlap(piece, snakePiece);
                        return doesOverlap; // terminate the loop if we've found a snake piece the given piece overlaps
                    } else {
                        return false; // if we're here, that means we're on the head when checkHead === false. return false to continue the loop.
                    }
                });
                return doesOverlap;
            }

            /** Returns random snake piece.. Useful for drawing food, which is basically a special snake piece */
            function getRandomPiece() {
                return {
                    x: getRandomCoordinate(),
                    y: getRandomCoordinate()
                };
            }

            /** Will return a random number between 0 and the canvas's playable area, that can be multiplied by the snake's side length to ensure a "grid" like flow.
            Canvas should be square or this quick function won't work */
            function getRandomCoordinate() {
                let canvasSide = mainCanvas.height;
                let maxValue = Math.floor(canvasSide / snakeSideLength);
                // One is the minimum - ensuring food is never added directly on the edge for a slightly more fair experience
                let randomInteger = Math.floor(Math.random() * (maxValue - 1) + 1); 
                return randomInteger * snakeSideLength;
            }

            /** @returns {boolean} true if two snake pieces, a and b, overlap */
            function doPiecesOverlap(a, b) {
                // Will be true if the pieces have no overlap at all, because of the following conditions are all false
                let isNoOverlap = (
                    a.x >= (b.x + snakeSideLength) || // a's left (x) is to the right of b's right edge (x + length)
                    a.y >= (b.y + snakeSideLength) || // a's top (y) is below b's bottom edge (y + length)
                    (a.x + snakeSideLength) <= b.x || // a's right is to the left of b's left edge
                    (a.y + snakeSideLength) <= b.y     // a's bottom is above b's top edge
                );
                return !isNoOverlap; // return the inverse so "true" will be returned if isNoOverlap = false, as that indicates there is overlap
            }

            /** Clears the game canvas by filling it with the background color */
            function clear() {
                mainCanvasContext.fillStyle = canvasColor;
                mainCanvasContext.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
            }

            /** Moves the snake by creating a new head and removing the tail, "shifting" the head forward giving an illusion of movement */
            function moveSnake(snake) {
                // Create a new snake head by cloning the current snake head
                let newSnakeHead = Object.assign({}, snake[0]);

                // Determine the axis of "movement" to add the new head to, and where to add the new piece to based on the size of snake pieces
                let axis = isDirectionOnXAxis(direction) ? "x" : "y";
                let isNegative = isNegativeDirection(direction);
                let newAxisValue = isNegative ? -snakeSideLength : snakeSideLength;
                newSnakeHead[axis] = newSnakeHead[axis] + newAxisValue;

                // If the movement would cause a game over, set that property and do not perform the move
                if (isGameOver(newSnakeHead)) {
                    gameOver = true;
                } else { // otherwise, perform the movement
                    // Set this piece's direction to the direction of movement during creation. Used to create tail pieces on food consumption
                    newSnakeHead.direction = direction;

                    // Add the new head to simulate movement
                    snake.unshift(newSnakeHead);

                    // If skipNextPopCycle = false, remove the tail to simulate true movement. If true, food has just been eaten, so skipping the pop adds a piece
                    // Set to false if true so that skipping only happens once per food eaten
                    !skipNextPopCycle ? snake.pop() : skipNextPopCycle = false;      
                }   
            }

            /** Given a new direction (up, right, down, left) set the snake's direction */
            function setDirection(newDirection) {
                direction = newDirection;
            }

            /** If the direction queue has entries, pulls the first one off the queue and sets the direction with it */
            function checkDirection() {
                if (directionQueue.length > 0) {
                    // Don't allow the snake to shift directions backwards - check if the potential direction would reverse directions and only set it if not
                    let potentialDirection = directionQueue.shift();
                    switch(potentialDirection) {
                        case directions.left: // left - set if not currently going right
                            direction !== directions.right ? setDirection(potentialDirection) : "";
                            break;
                        case directions.up: // up - set if not currently going down
                            direction !== directions.down ? setDirection(potentialDirection) : "";
                            break;
                        case directions.right: // right - set if not currently going left
                            direction !== directions.left ? setDirection(potentialDirection) : "";
                            break;
                        case directions.down: // down - set if not currently going up
                            direction !== directions.up ? setDirection(potentialDirection) : "";
                            break;
                    }
                }
            }

            /** Add a direction to the direction queue. Queue is used to prevent multiple direction changes in a single cycle from breaking the game. */
            function addToDirectionQueue(direction) {
                directionQueue.push(direction);
            }

            /** @returns {boolean} true if a given direction is on the X axis */
            function isDirectionOnXAxis(directionParam) {
                return directionParam === directions.left || directionParam === directions.right;
            }

            /** @returns {boolean} true if a given direction is in the negative direction of an axis */
            function isNegativeDirection(directionParam) {
                return directionParam === directions.left || directionParam === directions.up;
            }

            /** Draws a given snake on the canvas, using each object in the snake array's x and y coordinates */
            function drawSnake(snake) {
                mainCanvasContext.fillStyle = snakeColor;
                snake.map((snakePiece, index) => drawPiece(snakePiece));
            }

            /** Given a piece of a snake, draw it on the canvas. Assumes the fillStyle color has already been set. */
            function drawPiece(snakePiece) {
                mainCanvasContext.fillRect(snakePiece.x, snakePiece.y, snakeSideLength, snakeSideLength);
            }
        </script>
    </body>
</html>

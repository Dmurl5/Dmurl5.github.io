<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" href="data:;base64,=">
        <title> Basic Snake </title>
        <style>
            :root {
                --main-bg-color: #171717;
                --canvas-bg-color: #2f2f2f;
                --app-green: limegreen;
            }
            html {
                height: 100%;
                background-color: var(--main-bg-color);
                color: #eee;
                font-family: system-ui;
                font-size: 18px;
            }
            body {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            h1, h2, h3 {
                margin: 5px 0;
            }
            .info-display {
                background-color: var(--canvas-bg-color);
                margin: 20px 0;
                padding: 8px;
                display: flex;
                align-items: center;
                width: 480px;
                justify-content: space-around;
            }
            .game-info {
                flex-direction: column;
                align-items: unset;
                font-size: 14px;
            }
            #mainCanvasWrapper {
                width: auto;
                height: auto;
                background-color: var(--canvas-bg-color);
            }
            #playButton {
                background-color: inherit;
                border: 1px solid var(--app-green);
                color: var(--app-green);
                cursor: pointer;
                outline: none !important;
                font-size: 16px;
            }
            .score-display {
                color: var(--app-green);
                display: inline-block;
                min-width: 30px;
            }
            .arrows {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            .arrow {
                font-size: 24px;
                cursor: pointer;
                padding: 2px;
                margin: 5px 8px;
                display: inline-block;
            }
            .game-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
            }
        </style>
    </head>
    <body>
        <div class="info-display game-info">
            <div class="game-header">
                <h1><u>Snake</u></h1>
                <h3>Game Information</h3> 
            </div>
            <div>- Start the game via the Play button or by hiting Enter on your keyboard.</div>
            <div>- Change direction via your keyboard's arrow keys or the arrows on the bottom right.</div>
            <div>- The snake can't reverse direction without turning. He's not coordinated!</div>
        </div>
        <div id="mainCanvasWrapper">
            <canvas id="mainCanvas" width="500" height="500"></canvas>
        </div>
        <div class="info-display">
            <button id="playButton" onclick="setupAndPlay()">Play</button>
            <h4>Curent Score: <span class="score-display" id="currentScore">0</span></h4>
            <h4>High Score: <span class="score-display" id="highScore">0</span></h4>
            <div class="arrows">
                <div class="top"><span></span><span onclick="onUp()" class="arrow">&#8593;</span><span></span></div>
                <div class="middle"><span onclick="onLeft()" class="arrow">&#8592;</span><span></span><span onclick="onRight()" class="arrow">&#8594;</span></div>
                <div class="bottom"><span></span><span onclick="onDown()" class="arrow">&#8595;</span><span></span></div>
            </div>
        </div>

        <script>
            /* HTML Canvas and contexts - defined with types for easier use in IDE's */
            /** @type {HTMLCanvasElement} the canvas used to run and interact with the game */
            const mainCanvas = document.getElementById("mainCanvas");

            /** @type {CanvasRenderingContext2D} the 2d context used for snake */
            const mainCanvasContext = mainCanvas.getContext("2d");

            // These properties don't change during runtime and can be set as "const"
            const gameSpeed = 15; // indicates how fast the snake moves across the canvas, raise to increase speed
            const gameOverColor = "red"; // color to draw the snake as if the game is over
            const snakeSideLength = 15;
            const pointsPerFood = 10; // how many points you earn for each food item consumed
            const canvasColor = "#2f2f2f";
            const foodColor = "#c614d0";
            const directions = {up: "up", right: "right", down: "down", left: "left"}; // all available directions the snake can go

            // These properties change during runtime, and have their values reinitialized in the reset() function
            let snakeColor = "#0ba99f";
            let currentFood; // the current food piece on the canvas
            let velocity = { x: 0, y: gameSpeed, direction: directions.down }; // tracks the x and y velocity of the snake, as well as the head's current direction (could be derived but easier to just store it)
            let snake = [{x: 230, y: 230, direction: directions.down}]; // tracks the x and y position of each snake piece, as well as the direction it's travelling
            let gameOver = false; // if true, the user has lost - either by colliding with the edge or its own tail
            let velocityQueue = []; // queue for velocity changes to only allow one velocity shift per game cycle
            let currentScore = 0;

            // These properties change, but aren't reinitialized in reset() due to them persisting between games
            let highScore = 0;

            // Add a keydown listener for arrow keys, allowing for the snake to change direction when the user uses the arrow keys
            document.onkeydown = function(e) {
                switch (e.keyCode) {
                    // Enter key - restarts the game
                    case 13:
                        setupAndPlay();
                        break;

                    // Arrow key cases - controls the snake in the game
                    case 37: // left arrow
                        onLeft();
                        break;
                    case 38: // up arrow
                        onUp();
                        break;
                    case 39: // right arrow
                        onRight();
                        break;
                    case 40: // down arrow
                        onDown();
                        break;
                }
            };

            /** Functions for adding to the velocity queue when a direction is triggered (Arrow keys or the arrows on the page) */
            function onLeft() {
                addToVelocityQueue(directions.left);
            }
            function onUp() {
                addToVelocityQueue(directions.up);
            }
            function onRight() {
                addToVelocityQueue(directions.right);
            }
            function onDown() {
                addToVelocityQueue(directions.down);
            }

            /** Sets properties that can change over the course of the game to their initial values */
            function reset() {
                snakeColor = "#0ba99f";
                currentFood = undefined; // the current food piece on the canvas
                velocity = { x: 0, y: gameSpeed, direction: directions.down }; // tracks the x and y velocity of the snake, as well as the head's current direction (could be derived but easier to just store it)
                snake = [{x: 290, y: 290, direction: directions.down}]; // tracks the x and y position of each snake piece, as well as the direction it's travelling
                gameOver = false; // if true, the user has lost - either by colliding with the edge or its own tail
                velocityQueue = []; // queue for velocity changes to only allow one velocity shift per game cycle
                currentScore = 0;
                updateCurrentScore(currentScore);
            }

            /** Resets game values and calls play(). Triggered by the user clicking the Play button. */
            function setupAndPlay() {
                reset();
                // Give a small timeout before the game starts to allow for users to adjust between the play click and the game starting
                setTimeout(() => {
                    play();
                }, 50);
            }

            /**
                TODO's
                    (1) Make speed configurable - original 50 is too high for normal players
                    (2) Deploy to github pages
            */

            // Main game function. Calls itself recursively to run the game.
            function play() {
                gameOver = isGameOver(); // check if the user has lost whenever play() is called
                clear(); // clear the previous game state
                // if the game isn't over, perform game actions like moving the snake and checking for food
                if (!gameOver) {
                    checkVelocity();
                    snake = moveSnake(snake);
                    checkFood();
                }
                drawSnake(snake);
                if (gameOver) {
                    if (currentScore > highScore) {
                        updateHighScore(currentScore);
                    }                    
                }
                setTimeout(() => !gameOver ? play() : '', 60); // basically a tick(), redrawing the game canvas every X seconds. will not redraw if the game is over
            }

            /** Given a score, update the highScore and update the DOM element displaying it */
            function updateHighScore(score) {
                highScore = score;
                document.getElementById("highScore").innerText = highScore;
            }

            /** Given a score, update the currentScore and update the DOM element displaying it */
            function updateCurrentScore(score) {
                currentScore = score;
                document.getElementById("currentScore").innerText = currentScore;
            }

            /** Returns true if the game is over, because the user hit a side or a snake tail piece. consumeFood() can also set gameOver = true if a new snake piece can't be added */
            function isGameOver() {
                let snakeHead = snake[0];

                // Check for any movement-based game over states. If any are found, log the state of the loss.
                if (isPieceOffBoard(snakeHead)) {
                    console.log(`Lost from hitting the board's edge. Snake's head position: ${Object.values(snakeHead)}`);
                    console.log(`Velocity: ${Object.values(velocity)}`);
                    snakeColor = gameOverColor;
                    return true;
                } else if (doesPieceOverlapWithSnake(snakeHead, false)) {
                    console.log(`Lost from the snake's head hitting a tail piece. Snake:`);
                    console.table(snake);
                    console.log(`Velocity: ${Object.values(velocity)}`);
                    snakeColor = gameOverColor;
                    return true;
                } else {
                    return false;
                }
            }

            /** @returns {boolean} true if a given piece is off the board in either x or y axis */
            function isPieceOffBoard(piece) {
                let offBoard = piece.x < 0 || (piece.x + snakeSideLength) > mainCanvas.width; // check for off board in the x direction
                offBoard = offBoard || (piece.y < 0 || (piece.y + snakeSideLength) > mainCanvas.height); // check for off board in the y direction
                return offBoard;
            }

            /** Performs snake-food related actions, like building, drawing, or consuming it */
            function checkFood() {
                // First, check if the snake's head overlaps food - if so, consume it
                currentFood && doPiecesOverlap(snake[0], currentFood) ? consumeFood() : "";

                // If food doesn't exist, either from initial state or consumption, build it again
                if (!currentFood) {
                    currentFood = buildFood();
                }

                // Draw the current food object
                drawFood();
            }

            /** Destroys the food currently on the board and attempts to add a piece to the snake's tail */
            function consumeFood() {
                if (currentFood) {
                    // Clear the current food and determine the last snake piece's position
                    currentFood = undefined;

                    // Update the current score
                    updateCurrentScore(currentScore + pointsPerFood);

                    // Add a new piece to the snake. Adds to the tail, away from its direction.
                    let lastPiece = snake[snake.length - 1];

                    // Determine the direction to place the new square
                    let directionToPlace = lastPiece.direction === directions.up ? directions.down :
                                             lastPiece.direction === directions.down ? directions.up :
                                             lastPiece.direction === directions.right ? directions.left :
                                             lastPiece.direction === directions.left ? directions.right : '';

                    // If we can determine a direction to place the new piece, build a new square in the opposite direction of the terminal piece's direction
                    if (directionToPlace) {
                        let potentialPiece = {x: 0, y: 0};
                        let axis = isDirectionOnXAxis(directionToPlace) ? "x" : "y";
                        let isNegative = isNegativeDirection(directionToPlace);
                        let newAxisValue = isNegative ? -snakeSideLength : snakeSideLength;
                        let offset = isNegative ? -1 : 1; // The new potential piece should be offset by 1 to prevent collisions of the head and the next piece
                        potentialPiece[axis] = newAxisValue;
                        potentialPiece.x = potentialPiece.x + lastPiece.x + offset;
                        potentialPiece.y = potentialPiece.y + lastPiece.y + offset;

                        // Determine if the new piece would land on a square that would break the game. If not, push the piece onto the snake.
                        if (!(isPieceOffBoard(potentialPiece) || doesPieceOverlapWithSnake(potentialPiece, true))) {
                            snake.push(potentialPiece);
                            return;
                        }
                    } 

                    // if a new piece can't be placed for whatever reason, it's game over
                    gameOver = true;
                    snakeColor = gameOverColor;
                    return;
                }
            }

            /** Draws the currentFood object on the canvas */
            function drawFood() {
                mainCanvasContext.fillStyle = foodColor;
                drawPiece(currentFood);
            }

            /** Returns a new food object that doesn't overlap the snake. */
            function buildFood() {
                // Generate a random piece that does not overlap the snake
                let food;
                let doesOverlap = true;
                while(doesOverlap) {
                    food = getRandomPiece();
                    doesOverlap = doesPieceOverlapWithSnake(food, true);
                }

                // Once reached, we've generated a food piece that doesn't overlap the snake. Return it.
                return food;
            }

            /** Given a piece, check if it overlaps the snake. Will only check the head piece if checkHead === true. */
            function doesPieceOverlapWithSnake(piece, checkHead) {
                // Cache where the piece ends on both axis so it doesn't have to be calculated on each iteration
                let pieceXEnd = piece.x + snakeSideLength;
                let pieceYEnd = piece.y + snakeSideLength;
                // Check if the piece overlaps with any snake piece
                let doesOverlap = false;
                snake.find((snakePiece, index) => {
                    // Only run for index === 0 if checkHead === true
                    if (checkHead || index !== 0) {
                        doesOverlap = doesOverlap || doPiecesOverlap(piece, snakePiece);
                        return doesOverlap; // terminate the loop if we've found a snake piece the given piece overlaps
                    } else {
                        return false; // if we're here, that means we're on the head when checkHead === false. return false to continue the loop.
                    }
                });
                return doesOverlap;
            }

            /** Returns random snake piece.. Useful for drawing food, which is basically a special snake piece */
            function getRandomPiece() {
                return {
                    x: getRandomCoordinate(),
                    y: getRandomCoordinate()
                };
            }

            /** Will return a random number between 0 and the canvas's playable area. Canvas should be square or this quick function won't work */
            function getRandomCoordinate() {
                return Math.floor(Math.random() * (mainCanvas.height - snakeSideLength));
            }

            /** @returns {boolean} true if two snake pieces, a and b, overlap */
            function doPiecesOverlap(a, b) {
                // Will be true if the pieces have no overlap at all, because of the following conditions are all false
                let isNoOverlap = (
                    a.x >= (b.x + snakeSideLength) || // a's left (x) is to the right of b's right edge (x + length)
                    a.y >= (b.y + snakeSideLength) || // a's top (y) is below b's bottom edge (y + length)
                    (a.x + snakeSideLength) <= b.x || // a's right is to the left of b's left edge
                    (a.y + snakeSideLength) <= b.y     // a's bottom is above b's top edge
                );
                return !isNoOverlap; // return the inverse so "true" will be returned if isNoOverlap = false, as that indicates there is overlap
            }

            /** Clears the game canvas by filling it with the background color */
            function clear() {
                mainCanvasContext.fillStyle = canvasColor;
                mainCanvasContext.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
            }

            /** Moves the snake by the gameSpeed and velocity */
            function moveSnake(snake) {
                let snakeHead = snake[0];
                let prevPiece;
                return snake.map((snakePiece, index) => {
                    // If we're on the snake head, move the piece by the velocity. Otherwise, move each piece to the previous piece's old position
                    if (index === 0) {
                        prevPiece = Object.assign({}, snakePiece); // copy the snake piece to use it to move the next piece, without updating the copy when we update this piece
                        snakePiece = { // Move the snake head by the velocity
                            x: snakePiece.x + velocity.x,
                            y: snakePiece.y + velocity.y,
                            direction: velocity.direction
                        };
                    } else {
                        let pieceClone = Object.assign({}, snakePiece); // copy the snake piece to use it to move the next piece, without updating the copy when we update this piece
                        snakePiece = prevPiece; // set this piece's position equal to the previous piece's position
                        prevPiece = pieceClone;
                    }

                    return snakePiece;
                });
            }

            /** Given a direction (up, right, down, left) set the velocity for the snake based on that direction */
            function setVelocity(direction) {
                let velocityVal = isNegativeDirection(direction) ? -gameSpeed : gameSpeed; // determine the value to set the directional velocity to - negative game speed if a negative direction on an axis, positive if not
                let isX = isDirectionOnXAxis(direction) // determine if the direction is on the x axis - useful to shorten the velocity = {...} statement below
                velocity = {
                    x: isX ? velocityVal : 0,
                    y: !isX ? velocityVal : 0,
                    direction: direction
                };
            }

            /** If the velocity queue has entries, pulls the first one off the queue and sets the velocity with it */
            function checkVelocity() {
                if (velocityQueue.length > 0) {
                    // Don't allow the snake to shift directions backwards - check if hte potential velocity would reverse directions and only set it if not
                    let potentialVelocity = velocityQueue.shift();
                    switch(potentialVelocity) {
                        case directions.left: // left - set if not currently going right
                            velocity.direction !== directions.right ? setVelocity(potentialVelocity) : "";
                            break;
                        case directions.up: // up - set if not currently going down
                            velocity.direction !== directions.down ? setVelocity(potentialVelocity) : "";
                            break;
                        case directions.right: // right - set if not currently going left
                            velocity.direction !== directions.left ? setVelocity(potentialVelocity) : "";
                            break;
                        case directions.down: // down - set if not currently going up
                            velocity.direction !== directions.up ? setVelocity(potentialVelocity) : "";
                            break;
                    }
                }
            }

            /** Add a direction to the velocity queue. Queue is used to prevent multiple velocity changes in a single cycle from breaking the game. */
            function addToVelocityQueue(direction) {
                velocityQueue.push(direction);
            }

            /** @returns {boolean} true if a given direction is on the X axis */
            function isDirectionOnXAxis(directionParam) {
                return directionParam === directions.left || directionParam === directions.right;
            }

            /** @returns {boolean} true if a given direction is in the negative direction of an axis */
            function isNegativeDirection(directionParam) {
                return directionParam === directions.left || directionParam === directions.up;
            }

            /** Draws a given snake on the canvas, using each object in the snake array's x and y coordinates */
            function drawSnake(snake) {
                mainCanvasContext.fillStyle = snakeColor;
                snake.map((snakePiece, index) => drawPiece(snakePiece));
            }

            /** Given a piece of a snake, draw it on the canvas. Assumes the fillStyle color has already been set. */
            function drawPiece(snakePiece) {
                mainCanvasContext.fillRect(snakePiece.x, snakePiece.y, snakeSideLength, snakeSideLength);
            }
        </script>
    </body>
</html>
